name: Deploy Backend Softwave (to PUBLIC EC2)

on:
  push:
    branches: [ "release/sprint-final" ]
  pull_request:
    branches: [ "release/sprint-final" ]

permissions:
  contents: read
  id-token: write

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Build with Maven
        run: mvn clean package -DskipTests

      - name: Login to Docker Hub (runner)
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/backend-softwave:latest

  deploy-to-public:
    needs: build-and-push
    runs-on: ubuntu-latest
    timeout-minutes: 90
    steps:
      - name: Checkout (to access docker-compose.yaml if needed)
        uses: actions/checkout@v4

      - name: Remote deploy on PUBLIC EC2 (update .env, images and restart containers)
        uses: appleboy/ssh-action@v0.1.8
        with:
          host: ${{ secrets.EC2_HOST_PUBLIC }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          command_timeout: "30m"
          script_stop: true
          script: |
            #!/bin/bash
            set -euo pipefail
            set -x
            
            trap 'rc=$?; echo "!!! ERROR at line $LINENO (exit $rc)"; exit $rc' ERR
            
            EC2_USER="${{ secrets.EC2_USER }}"
            WORKDIR="/home/${EC2_USER}/app"
            
            echo ">>> Deploy start $(date)"
            echo "[info] WORKDIR=$WORKDIR"
            
            cd "$WORKDIR" || { echo "WORKDIR not found: $WORKDIR"; exit 2; }
            
            # Função segura para atualizar .env (evita que grep invalide o script)
            update_env() {
              local VAR_NAME="$1"
              local VAR_VALUE="$2"
              # normalizar valor (remove quebras de linha, escapa / e &)
              VAR_VALUE=$(printf '%s' "$VAR_VALUE" | tr '\n' ' ' | sed -e 's/[\/&]/\\&/g')
            
              # se .env existir, faz checagem segura; senão cria
              if [ -f .env ]; then
                # desativa errexit temporariamente para checar grep
                set +e
                grep -q "^${VAR_NAME}=" .env >/dev/null 2>&1
                local GREP_RC=$?
                set -e
                if [ ${GREP_RC} -eq 0 ]; then
                  sed -i "s|^${VAR_NAME}=.*|${VAR_NAME}=${VAR_VALUE}|g" .env
                  echo "[env] updated ${VAR_NAME}"
                else
                  echo "${VAR_NAME}=${VAR_VALUE}" >> .env
                  echo "[env] added ${VAR_NAME}"
                fi
              else
                echo "${VAR_NAME}=${VAR_VALUE}" >> .env
                echo "[env] added ${VAR_NAME} (file created)"
              fi
            }
            
            # garante existência e permissões do .env
            if [ ! -f .env ]; then
              echo ".env not found — creating empty .env"
              touch .env
              chmod 600 .env
            fi
            
            # ---------- Atualizar variáveis (vêm do GitHub Secrets) ----------
            update_env "DOCKERHUB_USERNAME" "${{ secrets.DOCKERHUB_USERNAME }}"
            update_env "DOCKERHUB_TOKEN" "${{ secrets.DOCKERHUB_TOKEN }}"
            update_env "DB_PASSWORD" "${{ secrets.DB_PASSWORD }}"
            update_env "DB_USER" "${{ secrets.DB_USER }}"
            
            # AWS credenciais (opcional: prefira IAM Role em produção)
            update_env "AWS_ACCESS_KEY_ID" "${{ secrets.AWS_ACCESS_KEY_ID }}"
            update_env "AWS_SECRET_ACCESS_KEY" "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
            update_env "AWS_SESSION_TOKEN" "${{ secrets.AWS_SESSION_TOKEN || '' }}"
            update_env "AWS_REGION" "${{ secrets.AWS_REGION || 'us-east-1' }}"
            update_env "AWS_S3_BUCKET" "${{ secrets.AWS_S3_BUCKET || 'softwave-arquivos-prod' }}"
            
            # Variáveis Spring/DB esperadas pelos containers
            update_env "SPRING_DATASOURCE_URL" "jdbc:mysql://mysql-db:3306/softwave_db"
            update_env "SPRING_DATASOURCE_USERNAME" "softwave"
            update_env "SPRING_DATASOURCE_PASSWORD" "${{ secrets.DB_PASSWORD }}"
            
            # Redact sensitive values from printed view
            echo ">>> .env keys present (sensitive values redacted):"
            # mostramos apenas as chaves, sem valores
            awk -F= '{print $1}' .env | sed -e 's/^/ - /' || true
            echo ">>> (secret values were not printed)"
            
            # ---------- Carregar .env para o ambiente de forma robusta ----------
            while IFS= read -r line || [ -n "$line" ]; do
              line="${line%%$'\r'}"
              [ -z "$line" ] && continue
              case "$line" in
                \#*) continue ;;
              esac
              key="${line%%=*}"
              val="${line#*=}"
              val="${val%\"}"
              val="${val#\"}"
              export "$key=$val"
            done < .env
            
            echo "Loaded ENV (names only):"
            echo " - DOCKERHUB_USERNAME=${DOCKERHUB_USERNAME:+set}"
            echo " - DB_USER=${DB_USER:+set}"
            echo " - AWS_REGION=${AWS_REGION:-<not-set>}"
            echo " - AWS_S3_BUCKET=${AWS_S3_BUCKET:-<not-set>}"
            echo " - SPRING_DATASOURCE_URL=${SPRING_DATASOURCE_URL:+set}"
            
            # fallback docker compose / docker-compose
            if ! command -v docker >/dev/null 2>&1; then
              echo "docker not found on remote host"
              exit 3
            fi
            if docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker compose"
            elif command -v docker-compose >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker-compose"
            else
              echo "Neither 'docker compose' nor 'docker-compose' available on remote host"
              exit 4
            fi
            
            # docker login (usando token)
            if [ -n "${DOCKERHUB_USERNAME:-}" ] && [ -n "${DOCKERHUB_TOKEN:-}" ]; then
              printf '%s' "${DOCKERHUB_TOKEN}" | docker login -u "${DOCKERHUB_USERNAME}" --password-stdin || echo "[warn] docker login failed (continuing)"
            fi
            
            # pull images
            echo ">>> ${DOCKER_COMPOSE_CMD} pull backend-softwave"
            ${DOCKER_COMPOSE_CMD} pull backend-softwave || echo "[warn] pull backend-softwave failed (continuing)"
            
            echo ">>> ${DOCKER_COMPOSE_CMD} pull other services"
            ${DOCKER_COMPOSE_CMD} pull api-auth-mail api-bucket-s3 api-consultas-softwave api-gemini-ia || echo "[warn] some service pulls failed (continuing)"
            
            # up
            echo ">>> ${DOCKER_COMPOSE_CMD} up -d --remove-orphans"
            ${DOCKER_COMPOSE_CMD} up -d --remove-orphans || { echo "[error] docker compose up failed"; ${DOCKER_COMPOSE_CMD} ps || true; exit 5; }
            
            echo "[deploy] ${DOCKER_COMPOSE_CMD} ps:"
            ${DOCKER_COMPOSE_CMD} ps || true
            echo ">>> Deploy finished $(date)"
